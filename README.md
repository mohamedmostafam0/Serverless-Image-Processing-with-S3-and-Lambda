# Serverless Image Processing Application

This project implements a robust and scalable serverless application for processing images. It leverages AWS services to automatically resize and store images uploaded via a modern web interface.

## Key Features

- **Modern UI:** A user-friendly web interface built with Bootstrap 5, featuring drag-and-drop functionality and real-time upload/processing feedback.
- **Secure Uploads (AWS Best Practice):** Implements pre-signed S3 URLs for direct, secure, and efficient image uploads from the client to S3, bypassing the backend server for data transfer.
- **In-Memory Image Processing:** The Lambda function processes images entirely in memory (`io.BytesIO`) to avoid common filesystem-related issues and improve performance.
- **Robust Error Handling:** Enhanced error handling in the Lambda function, including URL decoding for S3 object keys with special characters.
- **Automated Image Processing:** When an image is uploaded, an AWS Lambda function automatically resizes it and stores the processed version.
- **Metadata Storage:** Image metadata (original/processed dimensions, sizes, etc.) is stored in Amazon DynamoDB.
- **Serverless & Scalable:** Built on a serverless architecture, ensuring high scalability and cost-effectiveness (pay-per-use model).

## Architecture

The application follows a serverless, event-driven architecture:

1.  **Frontend (Browser):** The user interacts with a static HTML/JavaScript web page.
2.  **Pre-signed URL Generation (API Gateway + Lambda):** The frontend requests a secure, time-limited pre-signed URL from a dedicated API Gateway endpoint. A Lambda function generates this URL, granting temporary permission to upload directly to S3.
3.  **Direct Upload to S3:** The frontend uploads the image file directly to the designated S3 bucket using the pre-signed URL.
4.  **Image Processing Trigger (S3 Event):** The S3 upload event automatically triggers another AWS Lambda function.
5.  **In-Memory Image Processing:** This Lambda function downloads the image into memory, performs resizing (and can be extended for watermarking, etc.), and saves the processed image to an in-memory buffer.
6.  **Processed Image Storage:** The processed image is then uploaded from memory to a separate destination S3 bucket.
7.  **Metadata Storage:** Image metadata is stored in a DynamoDB table.
8.  **Processed Image Display:** The frontend polls for the processed image's availability and displays it using another pre-signed S3 URL generated by the backend.

![Architecture Diagram](architecture_diagram.drawio.png)

## User-API Interaction

The frontend application interacts with the backend API Gateway to get presigned URLs for uploading and downloading images. This process is designed to be secure and efficient, as the client interacts directly with S3 for the actual file transfers.

### Image Upload Flow

1.  **Request a Presigned URL for Upload:**
    *   The user selects an image to upload in the browser.
    *   The browser sends a `POST` request to the `/generate-upload-url` endpoint of the API Gateway.
    *   The request body is a JSON object containing the `filename` and `contentType` of the image.

2.  **Generate the Presigned URL:**
    *   The API Gateway triggers the `presign_lambda` function.
    *   The Lambda function receives the request and generates a presigned URL that allows a `PUT` operation on the `uploaded-images-bucket` with the specified `filename` and `contentType`.
    *   This URL is temporary and expires after a short period (currently 1 hour).

3.  **Upload the Image to S3:**
    *   The Lambda function returns the presigned URL to the browser.
    *   The browser then uses this URL to upload the image file directly to S3 with a `PUT` request. The request body is the image file itself.

### Processed Image Retrieval Flow

1.  **Poll for the Processed Image:**
    *   After the image is successfully uploaded, the browser begins to poll the `/get-processed-image-url` endpoint of the API Gateway.
    *   It sends a `GET` request with the `filename` of the *processed* image as a query parameter (e.g., `processed-my-image.jpg`).

2.  **Check for the Image and Generate a Presigned URL:**
    *   The API Gateway triggers the `presign_lambda` function for each polling request.
    *   The Lambda function checks if the requested file exists in the `processed-images-bucket`.
    *   If the file exists, the Lambda generates a presigned URL that allows a `GET` operation on the `processed-images-bucket`.
    *   If the file does not exist, the Lambda returns a 404 error, and the browser continues to poll.

3.  **Display the Processed Image:**
    *   Once the browser receives a presigned URL for the processed image, it uses the URL as the `src` for an `<img>` tag to display the image to the user.


## Key AWS Services Used

- **Amazon S3:** Stores original and processed images. Configured with CORS for direct browser uploads.
- **AWS Lambda:** Executes image processing and pre-signed URL generation logic.
- **Amazon API Gateway:** Provides secure, public endpoints for generating pre-signed URLs.
- **Amazon DynamoDB:** Stores image metadata.

## Getting Started

### Prerequisites

- An AWS Account
- AWS CLI configured with appropriate credentials
- Node.js and npm installed (for CDK)
- Python 3.11+ and `pip`
- Docker (for Lambda asset bundling)

### Deployment

1.  **Clone the repository:**

    ```bash
    git clone https://github.com/mohamedmostafam0/Serverless-Image-Processing-with-S3-and-Lambda.git
    cd Serverless-Image-Processing-with-S3-and-Lambda
    ```

2.  **Navigate to the CDK deployment directory:**

    ```bash
    cd cdk-deployment
    ```

3.  **Install Python dependencies:**

    ```bash
    python3 -m venv .venv
    source .venv/bin/activate
    pip install -r requirements.txt
    ```

4.  **Bootstrap CDK (if not already done):**

    ```bash
    cdk bootstrap aws://YOUR-AWS-ACCOUNT-ID/YOUR-AWS-REGION
    ```

    (Replace `YOUR-AWS-ACCOUNT-ID` and `YOUR-AWS-REGION` with your actual AWS account ID and region, e.g., `us-east-1`).

5.  **Deploy the stack:**
    ```bash
    cdk deploy
    ```
    This command will deploy all AWS resources, including S3 buckets, Lambda functions, API Gateway, and DynamoDB table. Note the `UploadApiUrl` output from the deployment.

### Running the UI

1.  **Open the UI:** Navigate to the `ui_app/templates/` directory.
2.  **Launch in Browser:** Open the `index.html` file directly in your web browser.

## Usage

1.  Open the `index.html` file in your browser.
2.  Drag and drop an image, or click to select one.
3.  Click "Upload Image".
4.  The image will be uploaded directly to S3, processed by the Lambda, and the processed version will be displayed on the page.

## Application UI

The user interface is a simple, single-page application that allows users to upload images and view the processed results.

![Application UI](UI.png)

## Contributing

Contributions are welcome! Please feel free to submit a pull request.

```
AWS_project/
├───.gitignore
├───architecture_diagram.drawio
├───architecture_diagram.drawio.png
├───README.md
├───cdk-deployment/
│   ├───.gitignore
│   ├───app.py
│   ├───cdk.json
│   ├───README.md
│   ├───requirements-dev.txt
│   ├───requirements.txt
│   ├───source.bat
│   ├───cdk_deployment/
│   │   ├───__init__.py
│   │   └───cdk_deployment_stack.py
│   ├───lambda/
│   │   ├───Dockerfile
│   │   ├───lambda_function.py
│   │   ├───requirements.txt
│   │   └───six.py
│   └───tests/
│       ├───__init__.py
│       └───unit/
│           └───test_cdk_deployment_stack.py
├───src/
│   └───creating_buckets.py
└───ui_app/
    ├───app.py
    ├───requirements.txt
    └───templates/
        └───index.html
```
